use crate::value::ValueType;

#[derive(PartialEq, Debug, Clone, Eq, Hash)]
pub enum TokenType {
    TokenLeftParen,
    TokenRightParen,
    TokenLeftBrace,
    TokenRightBrace,
    TokenComma,
    TokenMinus,
    TokenDot,
    TokenPlus,
    TokenSemicolon,
    TokenSlash,
    TokenStar,
    TokenPower,
    TokenStringStart,
    TokenStringEnd,
    TokenInterpolationStart,
    TokenInterpolationEnd,
    TokenBang,
    TokenBangEqual,
    TokenEqual,
    TokenEqualEqual,
    TokenGreater,
    TokenGreaterEqual,
    TokenLess,
    TokenLessEqual,
    TokenIdentifier,
    TokenString,
    TokenNumber,
    TokenTypeString,
    TokenTypeFloat32,
    TokenTypeFloat64,
    TokenTypeInt,
    TokenTypeInt8,
    TokenTypeInt16,
    TokenTypeInt32,
    TokenTypeInt64,
    TokenDeclaration,
    TokenMutable,
    TokenColon,
    TokenAnd,
    TokenClass,
    TokenElse,
    TokenFalse,
    TokenFor,
    TokenFn,
    TokenIf,
    TokenNull,
    TokenOr,
    TokenPrint,
    TokenReturn,
    TokenThis,
    TokenTrue,
    TokenWhile,
    TokenError(String),
    TokenEof,
}
impl TokenType {
    pub fn parse_to_type(&self) -> ValueType {
        match self {
            TokenType::TokenTypeString => ValueType::String,
            // TokenType::TokenTypeFloat32 => ValueType::Float32,
            TokenType::TokenTypeFloat64 => ValueType::Float64,
            // TokenType::TokenTypeInt => ValueType::Int,
            // TokenType::TokenTypeInt8 => ValueType::Int8,
            // TokenType::TokenTypeInt16 => ValueType::Int16,
            TokenType::TokenTypeInt32 => ValueType::Int32,
            TokenType::TokenTypeInt64 => ValueType::Int64,
            _ => ValueType::Empty,
        }
    }

    pub fn as_str(&self) -> &str {
        match self {
            TokenType::TokenLeftParen => "left parenthesis",
            TokenType::TokenRightParen => "right parenthesis",
            TokenType::TokenLeftBrace => "left curly brace",
            TokenType::TokenRightBrace => "right curly brace",
            TokenType::TokenComma => "comma",
            TokenType::TokenMinus => "minus",
            TokenType::TokenDot => "dot",
            TokenType::TokenPlus => "plus",
            TokenType::TokenSemicolon => "semicolon",
            TokenType::TokenSlash => "divide",
            TokenType::TokenStar => "multiply",
            TokenType::TokenPower => "power",
            TokenType::TokenStringStart => "string start",
            TokenType::TokenStringEnd => "string end",
            TokenType::TokenInterpolationStart => "interpolation start",
            TokenType::TokenInterpolationEnd => "interpolation end",
            TokenType::TokenBang => "not",
            TokenType::TokenBangEqual => "not equal",
            TokenType::TokenEqual => "equal",
            TokenType::TokenEqualEqual => "equal equal",
            TokenType::TokenGreater => "greater than",
            TokenType::TokenGreaterEqual => "greater than or equal",
            TokenType::TokenLess => "less than",
            TokenType::TokenLessEqual => "less than or equal",
            TokenType::TokenIdentifier => "identifier",
            TokenType::TokenString => "string literal",
            TokenType::TokenNumber => "number literal",
            TokenType::TokenTypeString => "string",
            TokenType::TokenTypeFloat32 => "f32",
            TokenType::TokenTypeFloat64 => "f64",
            TokenType::TokenTypeInt => "int",
            TokenType::TokenTypeInt8 => "i8",
            TokenType::TokenTypeInt16 => "i16",
            TokenType::TokenTypeInt32 => "i32",
            TokenType::TokenTypeInt64 => "i64",
            TokenType::TokenDeclaration => "declaration",
            TokenType::TokenMutable => "mut",
            TokenType::TokenColon => "colon",
            TokenType::TokenAnd => "and",
            TokenType::TokenClass => "class",
            TokenType::TokenElse => "else",
            TokenType::TokenFalse => "false",
            TokenType::TokenFor => "for",
            TokenType::TokenFn => "function",
            TokenType::TokenIf => "if",
            TokenType::TokenNull => "null",
            TokenType::TokenOr => "or",
            TokenType::TokenPrint => "print",
            TokenType::TokenReturn => "return",
            TokenType::TokenThis => "this",
            TokenType::TokenTrue => "true",
            TokenType::TokenWhile => "while",
            TokenType::TokenError(String) => "error",
            TokenType::TokenEof => "end of file",
        }
    }
}
